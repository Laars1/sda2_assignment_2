from pathlib import Path
from common.log_type import LogType
from plugins.plugin_caseconvertertoupper import CaseConverterToUpper
from plugins.plugin_summary import Summary
from plugins.plugin_topkeywords import TopKeyWords
from plugins.plugin_wordcounter import WordCounter


class CoreKernal:
    log_level = LogType.INFORMATION

    def __init__(self, log_level=None):
        if log_level:
            self.log_level = log_level

        self._plugins = []

        # Plugins register themselves with the core
        TopKeyWords().register(self)
        WordCounter().register(self)
        Summary().register(self)
        CaseConverterToUpper().register(self)

    def register_plugin(self, plugin):
        """
        Registers a plugin by appending it to the list of plugins.

        Args:
            plugin (object): The plugin instance to be registered. It is expected
                             that the plugin has a __class__.__name__ attribute.

        Prints:
            A message indicating that the plugin has been registered, including
            the name of the plugin class.
        """
        self._plugins.append(plugin)
        self.log(LogType.INFORMATION, f"Plugin {plugin.__class__.__name__} registered.")

    def execute_plugins(self, input: str, output: str):
        """
        Executes all registered plugins with the given input and output.

        Args:
            input (str): The input data to be processed by the plugins.
            output (str): The output data to be generated by the plugins.
        """
        for plugin in self._plugins:
            self.log(LogType.DEBUG, f"Executing plugin: {plugin.__class__.__name__}")
            plugin.execute(input, output)
            
        self.log(LogType.INFORMATION, "Output is also visible in output.txt")

    def execute_plugin(self, plugin_name: str, input: str, output: str):
        """
        Executes a plugin by its name.

        This method iterates through the list of available plugins and executes the one that matches the given plugin name.
        If the plugin is found, it calls the plugin's `execute` method with the provided input and output parameters.
        If the plugin is not found, it prints a message indicating that the plugin was not found.

        Args:
            plugin_name (str): The name of the plugin to execute.
            input (str): The input data to be passed to the plugin's `execute` method.
            output (str): The output data to be passed to the plugin's `execute` method.
        """
        for plugin in self._plugins:
            if plugin.__class__.__name__ == plugin_name:
                self.log(LogType.DEBUG, f"Executing plugin: {plugin_name}")
                plugin.execute(input, output)
                self.log(LogType.INFORMATION, "Output is also visible in output.txt")
                return
        
        self.log(LogType.WARNING, f"Plugin {plugin_name} not found.")

    def read_file(self, path: str):
        """
        Reads the content of a file specified by the given path.

        Args:
            path (str): The path to the file to be read.

        Returns:
            str: The content of the file.

        Raises:
            FileNotFoundError: If the file does not exist at the specified path.
        """
        try:
            with open(path, "r", encoding="utf8") as file:
                return file.read()
        except FileNotFoundError:
            self.log(LogType.ERROR, "File not found")

    def save_file(self, content: str, path: str, className: str):
        """
        Saves the given content to a file at the specified path, appending the content
        to the file if it already exists.

        Args:
            content (str): The content to be written to the file.
            path (str): The path where the file will be saved.
            className (str): The name of the class to be included in the file content.

        Raises:
            FileNotFoundError: If the file at the specified path cannot be found.

        Logs:
            Logs an informational message when the file is successfully saved.
            Logs an error message if the file cannot be found.
        """
        try:
            with open(path, "a+") as file:
                file.write(f"{className}:\n{content}\n\n")
            self.log(LogType.DEBUG, f"File saved in {path}")
        except FileNotFoundError:
            self.log(LogType.ERROR, f"File not found at {path}")

    def to_lower(self, content: str):
        return content.lower()

    def to_upper(self, content: str):
        return content.upper()

    def log(self, type: LogType, content: str):
        """
        Logs a message with a specified log type.
        Logs only message which are selected in within the log_level

        Args:
            type (LogType): The type of log message (INFORMATION, WARNING, ERROR, DEBUG).
            content (str): The content of the log message.

        Returns:
            None
        """

        log_levels = {
            LogType.INFORMATION: 1,
            LogType.WARNING: 2,
            LogType.ERROR: 3,
            LogType.DEBUG: 0,
        }

        if log_levels[type] >= log_levels[self.log_level]:
            print(f"{type}: {content}")

    def run(self):
        """
        Prompts the user to choose a plugin or type 'ALL' to execute all plugins.
        Executes the selected plugin(s) on the default input/output files until 'QUIT' is entered.

        Args:
            None

        Returns:
            None

        Logs:
            Logs an error if execution fails.
        """

        default_input = "input.txt"
        default_output = "output.txt"

        while True:
            chosen_plugin = input("Choose a plugin (Enter name of Plugin, type 'ALL' to execute all, or 'QUIT' to exit): ")
            
            if chosen_plugin == "QUIT":
                print("Exiting program.")
                break
            
            try:
                if chosen_plugin == "ALL":
                    self.execute_plugins(default_input, default_output)
                else:
                    self.execute_plugin(chosen_plugin, default_input, default_output)
            
            except Exception as e:
                self.log(LogType.ERROR, f"Error: {e}")